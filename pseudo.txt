
PROCEDURE `receive`
INPUT: 
	Socket `sock`
	Store with already-known identities `pub_key_store`
	`target_name`: Petname for the sender we want to 
	mutable reference to in-order delivery queue `in_order_delivery_queue`
	mutable reference to arbitrary order delivery queue `arbitrary_delivery_queue`
OUTPUT
	socket `sock` with updated state
	Store with updated identities and keys `pub_key_store`.

1) Block until receive a datagram  `dgram` with message ID, index and index count from `sock`
2) Insert it as a fragment to messages under message ID
3) If the message `raw_msg` is NOT complete:
	goto 1)
4) Call `verify(pub_key_store, raw_msg) -> (msg, seq, ver_state)`
5) If ver_state in {CERTIFIED, VERIFIED}:
	in_order_delivery_queue.enqueue(msg, seq, ver_state)
else 
	arbitrary_delivery_queue.enqueue(msg, seq, ver_state)
6) return (sock, pub_key_store)




PROCEDURE `verify`
INPUT: 
	`target_name`: A petname for the target sender.
	`pub_key_store`: Store with already-known identities 
	`raw_msg`: Raw message block 
OUTPUT
	`msg`: The actual message the sender sent.
	`seq`: The sequence number of the message in the stream.
	`ver_state`: Level of verification of the data along with the identity.
	OR 
	`error`

1) Try deserialize `raw_msg` to `msg`, `seq`, `pks` and `signature`, if failed:
	return Error
2) Load the pubkey this message should be signed with as `pk_hint` as the first item in `pks`.
3) Find the existing identities for `target_name` and load to `sender_id`
4) If `sender_id` is null: 
	Create a new identity for `target_name`	
	Insert `pk_hint`to the identity as the initial identity node.
5) Get the key from `pub_key_store` that is the same as `pk_hint` as `pk_ours`.
6) If `pk_ours` is null:
	return (msg, seq, Unverified)
7) 



